{"version":3,"sources":["mongoValidate.js"],"names":[],"mappings":";;;;;AAKI;;AACJ,QAAQ,gBAAR;AACA,QAAQ,qBAAR;;;;AAKA,IAAI,cAAY,QAAQ,0CAAR,EAAoD,WAApE;AACA,IAAI,cAAY,QAAQ,0CAAR,EAAoD,WAApE;;AAEA,IAAI,YAAU,QAAQ,2CAAR,EAAqD,SAAnE;;;;;AAMA,IAAI,sBAAoB;AACpB,cAAS,SADW;AAEpB,SAAI,KAFgB;AAGpB,SAAI,KAHgB;AAIpB,eAAU,WAJU;AAKpB,eAAU,WALU;AAMpB,YAAO,QANa,E;AAOpB,cAAS,QAPW,EAAxB;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqCA,IAAI,qBAAmB,SAAnB,kBAAmB,CAAS,GAAT,EAAa;AAChC,WAAO,IAAI,OAAJ,CAAY,UAAS,OAAT,EAAiB,MAAjB,EAAwB;AACvC,YAAI,QAAJ,CAAa,UAAS,GAAT,EAAa;;AAAA;AAAA;AAAA;;AAAA;AAEtB,qCAA0B,WAA1B,8HAAsC;AAAA,wBAA9B,cAA8B;;AAClC,wBAAG,CAAC,CAAD,KAAK,IAAI,OAAJ,CAAY,OAAZ,CAAoB,cAApB,CAAR,EAA4C;;AACxC,6BAAI,IAAI,eAAR,IAA2B,YAAY,cAAZ,CAA3B,EAAuD;;AACnD,gCAAG,IAAI,MAAJ,CAAW,eAAX,CAAH,EAA+B;;AAC3B,oCAAI,OAAK,IAAI,MAAJ,CAAW,eAAX,EAA4B,MAA5B,CAAT,C;;AAEA,oCAAG,UAAU,cAAV,EAA0B,eAA1B,EAA2C,oBAAoB,IAApB,CAA3C,CAAH,EAAyE;;AACrE,4CAAQ,UAAU,cAAV,EAA0B,eAA1B,EAA2C,oBAAoB,IAApB,CAA3C,EAAsE,YAAtE,CAAR;AACH;AACJ;AACJ;AACJ;AACJ;AAdqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAetB,oBAAQ,EAAC,IAAG,CAAJ,EAAR;AACH,SAhBD;AAiBH,KAlBM,CAAP;AAoBH,CArBD;;;;;;AA2BA,OAAO,OAAP,GAAe;AACX;;AADW,CAAf","file":"mongoValidate-compiled.js","sourcesContent":["/**\r\n * Created by ada on 2015/7/31.\r\n * classed by db\r\n */\r\n/*全部使用reslove返回数据，便于调试，以及便于通过rc判断*/\r\n    'use strict'\r\nrequire(\"babel-polyfill\");\r\nrequire(\"babel-core/register\")\r\n//mongo的validate error和input value共享一个定义\r\n//var mongoError=require('../../../../define/validateRule/inputRule').inputRule;\r\n\r\n\r\nvar collections=require('../../../../model/mongo/common/structure').collections\r\nvar fieldDefine=require('../../../../model/mongo/common/structure').fieldDefine\r\n//为了返回{rc:xxx,msg:'xxxxx'}格式的结果，只能requireinputRule（structure中的error msg是rc+msg的字符串格式，不太符合常用格式）\r\nvar inputRule=require('../../../../define/validateRule/inputRule').inputRule\r\n/*\r\n*  validate。使用同一的函数处理\r\n* */\r\n\r\n\r\nlet mongoKind2InputRule={\r\n    required:'require',\r\n    min:'min',\r\n    max:'max',\r\n    minlength:'minLength',\r\n    maxlength:'maxLength',\r\n    regexp:'format',//在mongo中，类型是match，但是返回的error中，kind是regexp\r\n    ObjectID:'format', //mongo中，objectId字段的只如果不是objectID，返回的error的kind是objectId；而在inputRule中，objectId使用format\r\n}\r\n\r\n\r\n\r\n/*  采用统一的函数进行mongo的validate（以前每个collection一个validate函数，不方便）\r\n* 根据validate的error信息直接找到inputValue中对应的rule的mongoError\r\n* 1. 遍历所有collection，检查err.message是否包含collection名称，以此判断validate err发生在哪个collection上\r\n* 2. 遍历collection的schema中的所有字段，查看对应的err.errors[field]是否存在，判断validate err发生在此collection的哪个field\r\n* 3. 读取此err的类型（mongo内建validator类型），然后从inputRule中读取到对应的错误，并返回错误代码（mongoError）\r\n* */\r\n/*var mongoValidate=function(doc,cb){\r\n    doc.validate(function(err){\r\n        for(let collectionName of collections){\r\n            if(-1!==err.message.indexOf(collectionName)){//判断当前错误是哪个collection产生的\r\n                for(let singleFieldName in fieldDefine[collectionName]){//遍历collection中的每个字段，是否在err中有对应的\r\n                    if(err.errors[singleFieldName]){//某个字段有error\r\n                        let kind=err.errors[singleFieldName]['kind']    //此field错误的类型\r\n                        if(inputRule[collectionName][singleFieldName][mongoKind2InputRule[kind]]){  //在inputValue中，对应的rule存在\r\n                            console.log(inputRule[collectionName][singleFieldName][mongoKind2InputRule[kind]]['mongoError'])\r\n                            return cb(inputRule[collectionName][singleFieldName][mongoKind2InputRule[kind]]['mongoError'])\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return cb({rc:0})\r\n    })\r\n}*/\r\nvar asyncMongoValidate=function(doc){\r\n    return new Promise(function(reslove,reject){\r\n        doc.validate(function(err){\r\n            //console.log(err)\r\n            for(let collectionName of collections){\r\n                if(-1!==err.message.indexOf(collectionName)){//判断当前错误是哪个collection产生的\r\n                    for(let singleFieldName in fieldDefine[collectionName]){//遍历collection中的每个字段，是否在err中有对应的\r\n                        if(err.errors[singleFieldName]){//某个字段有error\r\n                            let kind=err.errors[singleFieldName]['kind']    //此field错误的类型\r\n                            //console.log(inputRule[collectionName][singleFieldName][mongoKind2InputRule[kind]])\r\n                            if(inputRule[collectionName][singleFieldName][mongoKind2InputRule[kind]]){  //在inputValue中，对应的rule存在\r\n                                reslove(inputRule[collectionName][singleFieldName][mongoKind2InputRule[kind]]['mongoError'])\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            reslove({rc:0})\r\n        })\r\n    })\r\n\r\n}\r\n\r\n/*var test=async function(doc){\r\n    asyncMongoValidate(doc)\r\n}*/\r\n\r\nmodule.exports={\r\n    asyncMongoValidate,\r\n\r\n}\r\n\r\n"]}